<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="leetcode-note">leetcode note</h1>
<ul>
<li>ideas</li>
</ul>
<h2 id="num_sum-series">num_sum series</h2>
<ul>
<li><strong>two sum (number not sorted)</strong>: hash map to register (number, target-number) pairs</li>
<li><strong>two sum II (sorted)</strong>: two pointers algorithm.</li>
<li><strong>three sum</strong>: two pointers algorithm. Use one to sweep from start to end, the other to sweep backwards</li>
<li><strong>three sum closest</strong>: basically two pointers algorithm</li>
<li><strong>four sum</strong>: same two pointers algorithm as three sum. Remember to skip duplicate numbers</li>
</ul>
<h2 id="best-time-to-buy-and-sell-stock-series">best time to buy and sell stock series</h2>
<ul>
<li><strong>I and II</strong>: sweep. Consider this as 1D DP.</li>
<li><strong>III</strong>: divide left and right, do DP twice</li>
<li><strong>IV</strong>: 2D dynamic programming</li>
</ul>
<h2 id="intervals-series">intervals series</h2>
<ul>
<li><strong>merge interval</strong>: In Java, use Collections.sort(), so that insert interval is unnecessary</li>
<li><strong>insert interval</strong>: The first interval should be found by comparing ends with new interval.start</li>
</ul>
<h2 id="strings">strings</h2>
<ul>
<li><strong>word ladder</strong>: breadth first search, use string builder and hash set</li>
<li><strong>word ladder II</strong>: bfs, then dfs. Use map to track backwards path</li>
</ul>
<h2 id="stair-shape-stack-series">stair shape stack series</h2>
<ul>
<li><strong>largest rectangle in histogram</strong>: increasing stack to find border, <del>left and right sweep</del>, left to right sweep is enough, when decrease, current bar is right border. Upside down with container with most waster.</li>
<li><strong>maximal rectangle</strong>: loop of largest rectangle in histogram</li>
<li><strong>container with most water</strong>: decreasing stack to find border, left sweep is enough</li>
<li><strong>trapping rain water</strong>: decreasing stack</li>
<li><strong>trapping rain water II</strong>: actually BFS. Use queue to maintain spots that need to be checked again. Only check spots where water level is reduced, and their neightbors.</li>
</ul>
<h2 id="d-dynamic-programming">1D dynamic programming</h2>
<ul>
<li><strong>triangle</strong>: DP backwards</li>
<li><strong>maximum product subarray</strong>: use maximum and minimum to keep track of results. Don't use positive and negative!</li>
<li><strong>product of array except self</strong>: two sweeps</li>
</ul>
<h2 id="d-dynamic-programming-1">2D dynamic programming</h2>
<ul>
<li><strong>unique paths, unique paths II, minimum path sum, maximal square</strong>: maintain 2D matrix</li>
<li><strong>dungeon game</strong>: 2D backwards</li>
</ul>
<h2 id="arrays-misc">arrays misc</h2>
<ul>
<li><strong>set matrix zeros</strong>: use first row and column to keep flags</li>
<li><strong>search 2D matrix</strong>: binary search</li>
<li><strong>search 2D matrix II</strong>: search by corner from top right to bottom left.</li>
<li><strong>longest consecutive sequence</strong>: use set to get union</li>
</ul>
<h2 id="bucket-sort">bucket sort</h2>
<ul>
<li><strong>sort colors, remove duplicates from sorted array</strong>: bucket sort</li>
</ul>
<h2 id="quick-sort">quick sort</h2>
<ul>
<li><strong>sort list</strong>: have to use list trick and maybe find middle?</li>
</ul>
<h2 id="merge-sort">merge sort</h2>
<ul>
<li><strong>merge sorted array</strong>: merge from back to front</li>
</ul>
<h2 id="backtracking">backtracking</h2>
<ul>
<li><strong>subsets, word search</strong>: backtracking</li>
</ul>
</body>
</html>
